# tests/generators/test_pydantic_generator.py

import pytest
import re
from typing import Dict, Any

from Prism.generators.pydantic_generator import PydanticGenerator
from Prism.models.ir import IRModel
from Prism.models.dataschema import DataschemaModel
from Prism.exceptions import GenerationError

class TestPydanticGenerator:
    """Tests for the PydanticGenerator."""

    def test_generate_happy_path_single_contract(self, compiled_ir: IRModel):
        """
        Test generating Pydantic models from a valid IR with one contract.
        """
        # --- Act ---
        generated_code = PydanticGenerator.generate(compiled_ir)

        # --- Assert ---
        assert generated_code is not None
        assert isinstance(generated_code, str)

        # 1. Check for the auto-generated header and source recipe ID
        assert "# Auto-generated by Prompt Builder Core Framework (PBCF)" in generated_code
        assert f"Source Recipe: {compiled_ir.source_recipe_meta.id}" in generated_code

        # 2. Check for essential Pydantic imports
        assert "from pydantic import BaseModel" in generated_code

        # 3. Check for the generated class definition
        # The class name 'CodeInput' comes from the 'title' field in the JSON schema
        assert "class CodeInput(BaseModel):" in generated_code

        # 4. Check for the field definition
        # Use regex for flexibility, ignoring whitespace variations
        field_pattern = re.compile(r"user_code:\s+str")
        assert field_pattern.search(generated_code)

        # 5. Check for the field description as a docstring or comment
        assert "The code snippet provided by the user at runtime." in generated_code

    def test_generate_returns_none_for_ir_with_no_contracts(self, compiled_ir: IRModel):
        """
        Test that generate() returns None if the IR has no aggregated contracts.
        """
        # --- Arrange ---
        ir_no_contracts = compiled_ir.model_copy(deep=True)
        ir_no_contracts.aggregated_contracts = {}

        # --- Act ---
        result = PydanticGenerator.generate(ir_no_contracts)

        # --- Assert ---
        assert result is None
    def test_generate_with_multiple_contracts(self, compiled_ir: IRModel, dataschema_code_input: Dict[str, Any]):
        """
        Test generating code for an IR with multiple, distinct contracts.
        """
        # --- Arrange ---
        ir_multiple_contracts = compiled_ir.model_copy(deep=True)
        
        # Create a second, different contract
        second_contract_data = {
            "meta": {"id": "ds_user_profile", "name": "User Profile Schema"},
            "data": {
                "$schema": "https://json-schema.org/draft/2020-12/schema",
                "title": "UserProfile",
                "type": "object",
                "required": ["username", "age"],  # <--- 添加这一行
                "properties": {
                    "username": {"type": "string"},
                    "age": {"type": "integer"}
                }
            }
        }
        second_contract_model = DataschemaModel(**second_contract_data)
        
        # Add it to the IR
        ir_multiple_contracts.aggregated_contracts['ds_user_profile'] = second_contract_model

        # --- Act ---
        generated_code = PydanticGenerator.generate(ir_multiple_contracts)

        # --- Assert ---
        assert generated_code is not None

        # Check for the first model (it should still be correct)
        assert "class CodeInput(BaseModel):" in generated_code
        assert "user_code: str" in generated_code # ds_code_input.yaml has "required"

        # Check for the second model
        assert "class UserProfile(BaseModel):" in generated_code
        
        assert "username: str" in generated_code 
        assert re.search(r"age:\s+int", generated_code)

        # Ensure they are separated
        # 注意：由于字典是无序的，生成的模型顺序可能不固定。
        # 一个更健壮的检查是分别确认它们都存在，而不是依赖索引。
        assert "class CodeInput(BaseModel):" in generated_code
        assert "class UserProfile(BaseModel):" in generated_code

    def test_generate_raises_generation_error_for_invalid_schema(self, compiled_ir: IRModel):
        """
        Test that a GenerationError is raised if a contract contains a structurally invalid JSON Schema.
        """
        # --- Arrange ---
        ir_bad_schema = compiled_ir.model_copy(deep=True)
        
        # Get the existing contract and invalidate its schema's structure
        contract = ir_bad_schema.aggregated_contracts["ds_code_input"]
        
        contract.data["properties"] = ["this-is-not-a-dictionary"]

        # --- Act & Assert ---
        with pytest.raises(GenerationError) as exc_info:
            PydanticGenerator.generate(ir_bad_schema)
        
        # Check for a helpful error message
        error_message = str(exc_info.value)
        assert "为 contract 'ds_code_input' 生成 Pydantic 模型时出错" in error_message
        
        # Check if the underlying error is captured. It will likely be a TypeError or similar.
        # This makes the test more robust.
        assert "list" in error_message or "string indices must be integers" in error_message

