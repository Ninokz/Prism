# tests/generators/test_pydantic_generator.py

import pytest
import re
from typing import Dict, Any

from Prism.generators.pydantic_generator import PydanticGenerator
from Prism.models.ir import IRModel
from Prism.models.dataschema import DataschemaModel
from Prism.exceptions import GenerationError

class TestPydanticGenerator:
    """Tests for the PydanticGenerator."""

    def test_generate_happy_path_single_contract(self, compiled_ir: IRModel):
        """
        Test generating Pydantic models from a valid IR with one contract.
        """
        # --- Act ---
        generated_code = PydanticGenerator.generate(compiled_ir)

        # --- Assert ---
        assert generated_code is not None
        assert isinstance(generated_code, str)

        # 1. Check for the auto-generated header and source recipe ID
        assert "# Auto-generated by Prism" in generated_code 
        assert f"Source Recipe: {compiled_ir.source_recipe_meta.id}" in generated_code

        # 2. Check for essential Pydantic imports
        assert "from pydantic import BaseModel" in generated_code

        # 3. Check for the generated class definition
        # The class name 'CodeInput' comes from the 'title' field in the JSON schema
        assert "class CodeInput(BaseModel):" in generated_code

        # 4. Check for the field definition
        # Use regex for flexibility, ignoring whitespace variations
        field_pattern = re.compile(r"user_code:\s+str")
        assert field_pattern.search(generated_code)

        # 5. Check for the field description as a docstring or comment
        assert "The code snippet provided by the user at runtime." in generated_code

    def test_generate_returns_none_for_ir_with_no_contracts(self, compiled_ir: IRModel):
        """
        Test that generate() returns None if the IR has no aggregated contracts.
        """
        # --- Arrange ---
        ir_no_contracts = compiled_ir.model_copy(deep=True)
        ir_no_contracts.aggregated_contracts = {}

        # --- Act ---
        result = PydanticGenerator.generate(ir_no_contracts)

        # --- Assert ---
        assert result is None
    def test_generate_with_multiple_contracts(self, compiled_ir: IRModel, dataschema_code_input: Dict[str, Any]):
        """
        Test generating code for an IR with multiple, distinct contracts.
        """
        # --- Arrange ---
        ir_multiple_contracts = compiled_ir.model_copy(deep=True)
        
        # Create a second, different contract
        second_contract_data = {
            "meta": {"id": "ds_user_profile", "name": "User Profile Schema"},
            "data": {
                "$schema": "https://json-schema.org/draft/2020-12/schema",
                "title": "UserProfile",
                "type": "object",
                "required": ["username", "age"],
                "properties": {
                    "username": {"type": "string"},
                    "age": {"type": "integer"}
                }
            }
        }
        second_contract_model = DataschemaModel(**second_contract_data)
        
        # Add it to the IR
        ir_multiple_contracts.aggregated_contracts['ds_user_profile'] = second_contract_model

        # --- Act ---
        generated_code = PydanticGenerator.generate(ir_multiple_contracts)

        # --- Assert ---
        assert generated_code is not None

        # Check for the first model (it should still be correct)
        assert "class CodeInput(BaseModel):" in generated_code
        assert "user_code: str" in generated_code # ds_code_input.yaml has "required"

        # Check for the second model
        assert "class UserProfile(BaseModel):" in generated_code
        
        assert "username: str" in generated_code 
        assert re.search(r"age:\s+int", generated_code)

        # Ensure they are separated
        # 注意：由于字典是无序的，生成的模型顺序可能不固定。
        # 一个更健壮的检查是分别确认它们都存在，而不是依赖索引。
        assert "class CodeInput(BaseModel):" in generated_code
        assert "class UserProfile(BaseModel):" in generated_code

    def test_generate_raises_generation_error_for_invalid_schema(self, compiled_ir: IRModel):
        """
        Test that a GenerationError is raised if a contract contains a structurally invalid JSON Schema.
        """
        # --- Arrange ---
        ir_bad_schema = compiled_ir.model_copy(deep=True)
        
        contract_id = "ds_code_input"
        contract = ir_bad_schema.aggregated_contracts[contract_id]
        
        # 这是一个无效的结构，'properties' 应该是一个字典
        contract.data["properties"] = ["this-is-not-a-dictionary"]

        # --- Act & Assert ---
        with pytest.raises(GenerationError) as exc_info:
            PydanticGenerator.generate(ir_bad_schema)
        
        # 将错误信息转换为小写，以避免大小写问题
        error_message = str(exc_info.value).lower()

        # --- 断言关键信息 ---
        # 1. 检查顶层错误信息是否正确指出了失败的 contract
        assert f"failed to generate model for contract '{contract_id}'" in error_message
        
        # 2. 检查是否包含了“验证失败”这个核心原因
        assert "validation error" in error_message
        
        # 3. 检查出错的字段名是否存在
        assert "properties" in error_message 

        # 4. (这是最健壮的检查) 检查 Pydantic 的错误类型码
        #    'dict_type' 是机器可读的，比 'input should be a valid dictionary' 更稳定
        assert "dict_type" in error_message
