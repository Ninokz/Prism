# -*- coding: utf-8 -*-
# generators/pydantic_generator.py

import json
from typing import Optional, List

from datamodel_code_generator import DataModelType, PythonVersion
from datamodel_code_generator.model import get_data_model_types
from datamodel_code_generator.parser.jsonschema import JsonSchemaParser

from ..models.ir import IRModel
from ..exceptions import GenerationError

class PydanticGenerator:
    """
    根据 IR 中的 aggregated_contracts 生成 Pydantic 模型代码。
    """
    @staticmethod
    def generate(ir: IRModel) -> Optional[str]:
        """
        从 IR 生成一个包含所有 Pydantic 模型的 Python 模块字符串。
        如果 IR 中没有数据契约，则返回 None。
        """
        # 如果没有聚合的 contract，就不需要生成任何东西
        if not ir.aggregated_contracts:
            return None

        model_definitions: List[str] = []
        
        # 获取 Pydantic V2 的模型类型配置
        # 这使得我们可以指定目标 Python 版本和模型基类
        data_model_types = get_data_model_types(
            DataModelType.PydanticV2BaseModel,
            target_python_version=PythonVersion.PY_39 # 可以根据你的项目要求调整
        )

        for contract in ir.aggregated_contracts.values():
            try:
                # datamodel-code-generator 需要字符串或文件路径作为输入
                schema_str = json.dumps(contract.data)

                # 初始化解析器
                parser = JsonSchemaParser(
                    schema_str,
                    data_model_type=data_model_types.data_model,
                    data_model_root_type=data_model_types.root_model,
                    data_model_field_type=data_model_types.field_model,
                    data_type_manager_type=data_model_types.data_type_manager,
                )
                
                # 解析并生成代码
                result = parser.parse()
                if isinstance(result, str):
                    model_definitions.append(result)
                else:
                    # parser.parse() 在某些复杂情况下可能返回一个 dict
                    # 这里我们简化处理，只接受字符串结果
                    raise GenerationError(
                        f"无法为 contract '{contract.id}' 生成代码，解析结果不是字符串。"
                    )

            except Exception as e:
                # 捕获所有可能的解析和生成错误
                raise GenerationError(
                    f"为 contract '{contract.id}' 生成 Pydantic 模型时出错: {e}"
                ) from e
        
        # 组装最终的 Python 文件内容
        file_header = f"""# -*- coding: utf-8 -*-
                    # Auto-generated by Prompt Builder Core Framework (PBCF)
                    # Source Recipe: {ir.source_recipe_meta.id}
                    """
        # 将所有生成的模型代码块用空行隔开
        full_content = file_header + "\n\n\n".join(model_definitions)
        
        return full_content
